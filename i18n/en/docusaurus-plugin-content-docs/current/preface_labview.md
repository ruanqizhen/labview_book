# What is LabVIEW

## The LabVIEW Programming Language

LabVIEW stands out as the flagship software product of National Instruments (NI), setting itself apart from conventional programming languages through its unique graphical programming interface.

Traditional programming languages like C, Java, and Python are text-based, each with its specific application domains and features. They share a fundamental trait: using textual words to represent data, and sentences to perform computations and operations. These languages, mirroring the structure of human natural languages, are more concise, rigid, and precise, yet their lexical and grammatical concepts bear a resemblance to natural language systems.

Text-based languages are characterized by a high level of abstraction. Their strength lies in efficiency, enabling the expression of complex ideas in a compact form. However, they also have a significant drawback: their less intuitive nature makes them more challenging to learn. Mastery of a text-based language involves extensive time investment in learning and memorizing keywords, data representation methods, syntax, and more. The memorization and comprehension of keywords and functions, formed by letters, are particularly challenging, more so for non-native English speakers. Understanding a small code segment in isolation is often insufficient; one needs to read and interpret the entire code to grasp the underlying logic. For instance, determining the source and subsequent use of a variable in the code is not always intuitive in text languages. Full comprehension of the data flow and logic often requires a thorough reading and understanding of the entire program.

In computer interactions, graphical interfaces are generally more favored. Early DOS-based applications, with their text-based user interfaces, required users to input commands or data in response to text prompts. In contrast, later Windows-based applications adopted graphical interfaces, facilitating interaction through mouse-driven actions like dragging and clicking. The stark contrast in the popularity of these two approaches reflects a clear preference – graphical interfaces dominate most contemporary applications.

Many advanced programming languages have incorporated visual design methods, often referred to as WYSIWYG (What You See Is What You Get), for interface design. This approach spares programmers from entering textual commands, allowing them to use the mouse to shape and adjust the application's interface and see the effects in real-time. However, they are not true graphical programming languages, as their core functionalities still rely on textual code, despite the graphical tools used for designing interfaces.

LabVIEW revolutionizes this by not only employing graphical methods for interface design, akin to other advanced languages, but also in utilizing graphical operations for coding and implementing functions. Opening a LabVIEW program reveals a canvas of small graphical blocks interconnected by colorful lines, eschewing traditional text code. This innovative approach to programming is not only radically different but also more intuitive, making LabVIEW particularly suitable for beginners. A novice with no prior experience in computer software can often learn to create simple programs within just a few days – a rapid learning curve that is hard to achieve with other programming languages.

The efficiency of LabVIEW programming also surpasses that of text-based languages. LabVIEW offers an extensive array of toolkits, particularly beneficial in fields like measurement, control, and simulation. These toolkits provide most of the functionalities needed by programmers. As a result, a few simple graphics and connections in LabVIEW can replace dozens or even hundreds of lines of text-based code, highlighting the efficiency and power of graphical programming in LabVIEW.


## The Graphical Programming Language

G Language, short for Graphical Programming Language, finds its most comprehensive and powerful expression in LabVIEW. As such, LabVIEW is often considered synonymous with graphical programming languages and is sometimes directly referred to as G Language. In essence, LabVIEW functions as a development environment, much like Visual Studio, where the code crafted within is known as G Language code, comparable to how C code is written in Visual Studio.

A common misconception is that LabVIEW is merely an application specific to industrial measurement and control, not recognizing it as a full-fledged programming language. This misunderstanding stems from two main factors. Firstly, LabVIEW’s distinct departure from conventional programming languages leads to its association with specialized applications like circuit board wiring or industrial bus configuration. Secondly, LabVIEW’s predominant use in measurement and control fields has limited broader understanding among users.

When working with LabVIEW, it's crucial to adopt a programming mindset. The software development process in LabVIEW mirrors that of other programming languages, encompassing requirement gathering, design, coding, testing, release, and maintenance. While prior experience with other programming languages is beneficial, learning LabVIEW requires an understanding of the unique differences between graphical and textual programming languages. Some strategies and experiences from text-based languages may not directly translate to LabVIEW. This book aims to elucidate LabVIEW's distinctive features compared to traditional text-based languages, offering insights to help those familiar with textual programming recognize and adapt to these differences.

For beginners who choose LabVIEW as their gateway into the realm of programming, this comparative perspective will be also a valuable guide. It will serve as a reference point as they expand their skills into other programming languages in the future.

## The Versatile Applications of LabVIEW

LabVIEW, renowned for its multitude of advantages, is particularly effective in certain specialized fields. In such domains, LabVIEW emerges as the preferred choice for software development due to its distinctive capabilities.

- **Test and Measurement:** Originally designed for test and measurement purposes, LabVIEW has become the go-to solution in this arena. Over time, it has garnered extensive support in the test and measurement field. The majority of mainstream testing instruments and data acquisition devices are equipped with LabVIEW drivers, streamlining the control of these devices. Furthermore, a wide array of LabVIEW toolkits, tailored for test and measurement applications, provides comprehensive functionality, simplifying the software development process. In some cases, integrating just a handful of functions from these toolkits can yield a complete test and measurement application.

- **Control Systems:** LabVIEW's evolution from testing to control systems is a natural progression. The LabVIEW DSC module, specifically designed for control applications, enhances its capabilities in this field. Additionally, LabVIEW drivers are commonly available for a range of devices and data lines used in industrial control, facilitating the programming and fine-tuning of various control systems.

- **Simulation and Prototyping:** With its diverse array of mathematical functions, LabVIEW is exceptionally suited for simulation, prototyping, and design. It enables the creation of computer-based simulation prototypes to validate design concepts and identify potential issues before the actual construction of electromechanical devices. In academic settings, LabVIEW can simulate experiments that might be impractical due to resource constraints, thus preserving hands-on learning experiences for students.

- **Education for Children:** LabVIEW's visually appealing and intuitive interface has made it a favorite among children. It serves as an innovative "building block" tool that allows children, even those without prior computer knowledge, to assemble various components to achieve desired functionalities. The popular programmable LEGO toy, for instance, utilizes LabVIEW. With minimal guidance, children can build and program various models, such as vehicles and robots, using LabVIEW. The software also boasts versions specifically designed for teaching in primary and secondary education.

- **Rapid Development:** My experience in various projects suggests that a proficient LabVIEW programmer can complete large-scale applications with functionality similar to those developed in C in approximately one-fifth of the time. This efficiency makes LabVIEW an ideal choice for projects with tight development schedules.

- **Cross-Platform Compatibility:** LabVIEW stands out for its cross-platform capabilities. It runs seamlessly on major desktop operating systems like Windows, macOS, and Linux without any code modifications. Beyond these, LabVIEW supports a range of real-time operating systems and embedded devices, including PDAs, FPGAs, and RT systems operating on VxWorks and PharLap, making it a versatile tool for diverse hardware applications.

## The Evolution of LabVIEW

National Instruments (NI), established in 1976, has consistently aimed to integrate traditional test and measurement instruments with personal computers. During its early years, the most common I/O interface in traditional instruments was the GPIB (General Purpose Interface Bus). NI's initial breakthrough product was a GPIB interface card for personal computers, allowing for the seamless exchange of data between traditional instruments and PCs. This innovation laid the groundwork for software development that could control hardware more efficiently and provide enhanced data analysis capabilities.

A decade after its founding, in 1986, NI introduced a software named Laboratory Virtual Instrument Engineering Workbench, known more popularly as LabVIEW.

- **LabVIEW 1.0:** Developed for the then-trendy Apple computers, which were the first to bring graphical user interfaces to personal computing. Inspired by this, NI's engineers designed LabVIEW with a fully graphical operating interface. The Apple computers of that era utilized Motorola's 68000 CPU. LabVIEW 1, unlike its successors, was an interpreted language with simple syntax and functionality, limited to basic operations like handling single data types and supporting only floating-point numbers.

- **LabVIEW 1.1:** This version brought a significant optimization technique, cache reuse, to the forefront. This approach, crucial in LabVIEW's data flow-driven programming style, minimized unnecessary data duplication and significantly boosted efficiency. Today, efficient cache reuse remains a key focus for LabVIEW programmers optimizing memory usage.

- **LabVIEW 2.0:** Marked a paradigm shift from an interpreted to a compiled language. It compiled code into machine code for Motorola's 68000 CPU before execution, leading to a substantial increase in performance. This version also introduced syntax checks during compilation and began supporting parallel computation, a precursor to multithreading, by internally scheduling segments of code that had no sequential dependencies.

- **LabVIEW 2.5:** It was a significant milestone by introducing support for x86 architecture CPUs, initiating its trend towards cross-platform capability. Since then, LabVIEW has continually expanded its support to include PowerPC and other mainstream CPUs, solidifying its status as one of the most platform-diverse programming languages available. This broad support spectrum, however, brought certain challenges. For instance, the LabVIEW development environment's interface, with its dark gray panels and distinct 3D buttons, does not align with the standard Windows application aesthetic, potentially leading to a learning curve for users accustomed to Windows interfaces. This divergence stems from LabVIEW's commitment to multi-platform compatibility, preventing the simple adoption of Windows-native interface elements. Another subtle but notable difference lies in data handling: LabVIEW, even on x86 systems, employs a big-endian format for integer storage, which is the opposite of the more commonly used format in modern x86 CPUs. This aspect can introduce complexities when writing programs that interact with binary files.

- **LabVIEW 3:** The introduction of LabVIEW 3 saw the addition of innovative features like property nodes and local variables. By this point, the user base had grown, with developers creating extensive applications comprising thousands of VIs, pushing the boundaries of what could be achieved with LabVIEW.

- **LabVIEW 4:** It holds the distinction of being the first version I used. Its release was characterized by a bulky package containing a dozen three-inch floppy disks, requiring sequential installation. Despite its then less-than-modern interface, LabVIEW captivated me with its user-friendly design. For example, adding a switch to a program was as effortless as dragging a pre-made control from the control palette, a feature not found in text-based programming languages of that era. Designing a similar switch in C would have been a time-intensive task. LabVIEW's unique programming-by-connecting-wires approach, though initially challenging for those accustomed to text-based languages, offered a novel and efficient way to develop software.

- **LabVIEW 5:** Introduced the GenAPI module, significantly improving support for a wide range of hardware devices. GenAPI enabled LabVIEW to generate executable codes compatible with multiple CPUs, thus facilitating cross-compilation capabilities. This allowed for the compilation of programs on an x86 computer, for instance, to be run on real-time (RT) devices. A pivotal enhancement in LabVIEW 5.0 was the introduction of multithreading support, marking a major stride in its programming efficiency and application scope.

- **LabVIEW 6:** Brought in visually appealing 3D effect controls, adding a new dimension to user interface design. It also expanded its capabilities with robust support for event handling and network programming, broadening the possibilities for more complex and interactive applications.

- **LabVIEW 7:** Introduced Express VIs, simplifying and accelerating the development process. Additionally, this version extended LabVIEW's programming support to embedded devices, including Field-Programmable Gate Arrays (FPGAs) and Digital Signal Processors (DSPs), thereby enhancing its applicability in specialized hardware programming.

- **LabVIEW 8:** Brought significant advancements in its compiler technology, particularly in optimizing CPU register allocation. Moving away from the fixed allocation pattern of previous versions, LabVIEW 8 implemented dynamic allocation, which allowed for more efficient use of CPU resources. The compiler was also enhanced with new optimization techniques, such as the removal of invalid code branches, streamlining the code for better performance. In the realm of project management, LabVIEW 8 introduced innovative features like project libraries and object-oriented programming, providing developers with more tools to manage large-scale projects effectively.

- **LabVIEW 2009:** marked a significant milestone with considerable improvements to its compiler. A notable addition was the introduction of a 64-bit compiler, capable of generating 64-bit executables, catering to the growing demand for more powerful computing capabilities. This version also initiated a layered approach to the LabVIEW compiler, starting with the DFIR (Dataflow Intermediate Representation) layer. This layer, acting as an intermediary between the program block diagram and the executable code, allowed the compiler to implement more sophisticated optimizations, such as constant merging, elimination of redundant code, and relocating invariant code outside loops.

- **LabVIEW 2010:** Further refined its compiler structure with the addition of the LLVM (Low-Level Virtual Machine) layer, bridging between DFIR and machine code. This enhancement enabled more advanced optimization techniques, including instruction scheduling, loop condition extraction, combined instruction sets, and intricate register allocation. Additional optimization strategies were incorporated into the DFIR layer, including operation association, common subexpression elimination, loop unrolling, and inlining of sub VIs, significantly improving the efficiency and performance of LabVIEW applications.

- **From 2011 onwards:** NI began to gradually pivot its development efforts towards LabVIEW NXG, envisioned as the successor to the traditional LabVIEW platform. Despite this strategic move, LabVIEW NXG struggled to gain traction among users. In 2020, NI made the decision to discontinue the development of LabVIEW NXG. Throughout this decade, constrained by limited resources, LabVIEW primarily received minor updates and bug fixes, with less emphasis on major technological breakthroughs.

- **In 2020:** Acknowledging the crucial role of accessibility in education and research, NI launched a community edition of LabVIEW in 2020. This complimentary version substantially reduced entry barriers, enabling enthusiasts and learners to delve into and leverage LabVIEW without the hindrance of financial limitations. Additionally, this release allowed me to resume maintaining this book after a 10-year hiatus due to previously not having access to LabVIEW.

- **In 2023:** NI being acquired by Emerson. This acquisition marked a new chapter in the history of LabVIEW, potentially heralding changes in its development and application in various fields.
