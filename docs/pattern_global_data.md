# 全局变量

全局变量与[局部变量](data_and_controls)类似，是一种可以让数据随时流入流出其间的对象。它与局部变量的区别在于，局部变量只能在其对应控件所在的 VI 中使用，而全局变量可以在一个程序中的任意 VI 上使用。使用全局变量时，数据被保存在某一固定的内存空间内，不随数据线流动，在需要读写数据的地方，直接对全局变量进行操作即可。

LabVIEW 的全局变量和局部变量是非常容易被滥用的功能。它们看似用起来很方便，可以随时随地读写数据，但是它们非常不安全，容易导致一些莫名其妙又难以调试的错误，同时它们还破坏了数据流顺序的逻辑关系，导致程序可读性和可维护性下降。所以应当尽量避免在程序中使用全局变量和局部变量。我们在[局部变量](data_and_controls)一节已经讨论了可以使用局部变量的情况。对于全局变量，笔者建议仅在把它当做常量定义的时候使用它，其它情况都避免使用。下面我们详细讨论一下全局变量的用法和问题。


## 全局变量

### 创建全局变量
在 LabVIEW 的新建对话框中选择“全局变量”即可创建出一个空白的全局变量 VI。

![](images/image263.png "创建全局变量")

或者在一个 VI 的程序框图上，选择函数选板的“编程 -\> 结构 -\> 全局变量”，就可创建出一个空白的全局变量实例，双击这个全局变量实例，可以打开一个空白的全局变量 VI。全局变量 VI 是一种特殊的 VI，它只有前面板，没有程序框图。在全局变量 VI 的前面板上可以放置多个控件，每个控件表示一个全局变量数据。由于一个全局变量 VI 可以存放多个全局变量数据，在编程时，可将相关度较大的全局变量数据放在一个全局变量 VI 中，以便于管理。

![](images/image264.png "全局变量 VI")

不论控件是控制型的还是显示型的，它所表示的全局变量都既可读，也可写。在 VI 上任何需要使用这个全局变量数据的地方，把全局变量 VI 拖到程序框图上即可生成全局变量实例，然后对其进行读写。下图中内含小地球图标的矩形方块就是一个全局变量实例，在同一版本 LabVIEW 的程序框图上，全局变量与局部变量的外观是一致的，只有图标有所区别，一个是小地球，一个是小房子。

![](images/image265.png "使用全局变量实例")

通过这个全局变量实例，程序可以读写全局变量中的数据。如果一个全局变量 VI 上有多份全局变量数据（多个控件），在这个全局变量 VI 对应的实例上点击鼠标左键，或在右键菜单的“选择项”中，可以选择这个实例将要读写全局变量中的哪个数据。

通常，在不会引起误解的情况下，可以把全局变量 VI、全局变量数据、全局变量实例，都简称为全局变量。

### 数据竞争状态

竞争状态是指在多个线程中，由于同时访问同一资源所引发的程序结果的不确定的状况。比如下面这个程序，假设全局变量 Data 的值原本为 0，运行完下面这个 VI，Data 中的值是几呢？

![](images/image266.png "处于竞争状态的全局变量")

从程序的逻辑上看，它先把 Data 加 2 再减 1，程序设计的意图是希望结果为 1。但实际上，运行 VI 后，Data 的值可能是 1，也有可能是 2，还可能是 -1。程序中的代码分为上下两个部分，两部分之间没有数据线相连。按照我们前面所介绍的 LabVIEW 的运行机制，这两部分的代码应当同时在不同的线程内运行。这里需要更确切地解释一下：所谓同时运行是一个宏观的说法，在宏观的时间范围内，计算机可以同时执行两个任务。但是，从微观的角度来看可能并不是真正的“同时”，它更可能是两个任务交替进行。比如，对于只用一个 CPU 的计算机来说，这个 CPU 在任何时候只能执行一个任务。不过它可以在某几个纳秒之内，执行任务 A，而下几个纳秒再去做另一任务 B，下几个纳秒再回来执行任务 A。CPU 就这样在两个任务之间快速地来回切换。虽然，在微观上看，某一特定的时刻只执行一个任务，但是在宏观上看，这两个任务是同时进行的。

局部变量同样会引起竞争状态，比如下图中的程序：

![](images_2/z250.png "处于竞争状态的局部变量")

这个程序为了提高竞争状态出现的概率，在程序中添加了两个延时子 VI“Stall Data Flow.vim”，它们会让程序延时一毫秒。同样假设局部变量 Numeric 的初始值是 0。

* 如果程序执行的顺序是，先在 A 处取出数据 0，加 1，再在 B 处写入数据，这时局部变量数值为 1，再从 C 处取出数据，还是 1，减 1,在 D 处写入结果。最终局部变量的结果是 0。
* 如果程序先在 A 处取出数据 0，加 1，然后从 C 处取出数据，这时局部变量中的数据仍然是 0，之后在 B 处写入数据 1，之后再把从 C 处读取的 0 减 1，在 D 处写入结果。最终局部变量的结果是 -1。
* 如果程序先在 A 处取出数据 0，加 1，然后从 C 处取出数据，然后减 1，在 D 处写入结果 -1，之后在 B 处写入数据 1，这样程序的最终局部变量的结果是 +1。

我们肯定不会希望自己的项目里有这种结果不确定的程序出现。相比之下，全局变量比局部变量更糟糕，因为局部变量只在一个 VI 内有效，我们如果认真检查一个 VI，也许可以排查出有竞争状态的代码。但全局变量在所有的 VI 内都可以被读写，排查问题的难度就被大大增加了。尤其是在有多人合作的大型项目中，我们可能很难确保一个全局变量有没有被别人在其它某个 VI 里改动了。

除了可能出现的竞争状态，全局变量会降低代码的可读性，因为代码上的全局变量，不能直观地反映出它的数据来源。VI 每次读取全局变量数据，LabVIEW 都要为读到的数据复制一个新的副本，这导致它的运行效率也比较低。鉴于这么多的缺点，我们应该尽量避免使用全局变量。

### 常量定义

笔者唯一能想到的比较适合使用全局变量的应用，是在小型项目中，把它当做常量来使用。所谓常量，就是在程序运行过程中不会改变的数据。直接把常量数据硬编码在程序中，会不利于程序维护。比如，我们编写了一个生成报表的程序，其中段落的字号是“10”，于是，在程序的各个 VI，不同的地方都使用了“10”这个数据。然而，有一天，客户突然要求，使用 11 号字体，于是我们就必须把程序中每个 10 都找出来，替换成 11。这样几麻烦，也容易遗漏一些数据。理想情况是设置一个名为“字号”的常量，它的值是 10。在程序中所有需要设置字号的地方，都不能直接使用数字 10，而是必须使用“字号”常量来设置字号。当客户要求把字号改为 11 是，只要改变“字号”常量的值就可以了，程序任何其它地方都不需要改动。

文本编程语言中，常量应用的非常普遍。比如 C 语言使用宏定义常量； C++、Java 等使用关键字 Const 定义常量。LabVIEW 中没有专门的常量定义方法。如果程序所需的常量不多，可以直接使用 VI 返回一个数据作为常量。比如上文中的例子，可以定义一个名为“字号.vi”的 VI，它有一个输出参数，就是字号的数据。如果项目中需要的常量比较多，每个常量都配一个 VI 会比较麻烦，而且会搞不清楚那些 VI 是用作常量的。可以考虑一个比较简单的实现常量的方法，就是使用全局变量。

我们可以约定好，程序中任何地方都只可以读取全局变量的值，但不能改变任何全局变量的值。一个全局变量如果没有在程序里被设置过，那么它的值，就是全局变量 VI 上，那些[控件的默认值](data_and_controls#控件的默认值)。


## 共享变量

共享变量与全局变量相比，其作用域更广。它不但可以在不同的 VI 之间传递数据，还可以在不同的程序，甚至不同的计算机以及硬件设备间传递数据。在实际应用中，共享变量主要用于网络上不同 VI 的数据共享，或读写其它硬件设备上的数据。

共享变量的创建方法与全局变量相同，可以从模板中创建，也可以在项目浏览器的右键菜单中选择 "新建 -\> 变量"，创建出一个共享变量。共享变量不是一个单独的 VI，它是 LV 库的一部分，它只能创建在某个 LV 库（lvlib 文件）下。

创建共享变量时，首先会弹出共享变量属性对话框，设置共享变量的名称、类型等属性（图
4.27）。共享变量有三种：单进程、网络发布、以及时间触发的共享变量。时间触发的共享变量应用于 LabVIEW 实时系统模块，安装了 LabVIEW 实时模块后才可以使用。

![](images/image267.png)

图 .27 共享变量属性对话框

单进程和网络发布的共享变量仅作用域不同，使用方法是相同的。这里着重介绍一下单进程共享变量。

单进程共享变量，顾名思义就是作用域为单个应用程序进程的共享变量。它与全局变量的性质是完全相同的。唯一的不同点是单进程共享变量都带有错误输入 / 输出端，我们可以利用错误处理连线来控制单进程共享变量的执行顺序。例如图
4.28 中的 VI，假设共享变量 Data 的值原本为 0，运行完下面这个加 2 减 1 的代码后，Data 的值必然为 1。

![](images/image268.png)

图 .28 共享变量的应用

但是，这并不意味着单进程共享变量可以防止出现竞争状态。设想图
4.28 中的 VI 只是程序中的一个子 VI，在其运行的同时，Data 还是可以在其它子 VI 中被访问修改的，依然可能处于竞争状态。

## 功能全局变量

利用循环结构中移位寄存器的特性，也可以保存全局数据。使用这种方式保存全局数据的子 VI 叫做功能全局变量。功能全局变量的基本结构模式都是类似的：主体是一个循环条件结构；有一个用于选择某种操作的输入控件；一对或多对分别用于输入和输出数据的控件。它能实现相关的访问这些数据的方法（也称作对数据的操作）。

功能全局变量中使用循环结构只是为了利用它的移位寄存器。移位寄存器并不连接任何初始化数据。每次执行这个 VI 时，它能够读出上一次执行时存入移位寄存器的数据，并把这一次 VI 执行结束时的数据存入移位寄存器。这样，就可以在程序的全程保存、处理或使用移位寄存器中的数据了。功能全局变量 VI 绝对不可以被设置为可重入，否则在程序不同之处得到的移位寄存器中的数据就不是同一份了。

功能全局变量的程序框图如图 4.29 所示。

![](images/image269.png)

图 .29 带有加减法功能的功能全局变量

在这个例子中，程序使用了一个未初始化的移位寄存器保存全局数据；通过 "操作" 输入参数来选择需要执行的四种操作；"数据输入 / 输出" 分别用于给不同的操作提供或返回数据。

功能全局变量与前面提到的两种全局变量最大的区别在于：其它的全局变量只能读写数据；功能全局变量除了读写数据之外，还可以按程序要求实现对数据的其它操作。并且，所有对全局数据的操作都必须通过全局变量提供的方法来完成。

这个例子中的全局变量提供了 4 个相关的操作："取出数据" 用于返回功能全局变量保存的数据；"清零" 用于把功能全局变量保存的数据清零；"加法" 用于给保存的数据再加上输入的数值；"减法" 是在保存的数据上减去输入的数值（图
4.30）。

![](images/image270.png)

![](images/image271.png)
![](images/image272.png)

图 .30 功能全局变量其它几个操作分支

对于仅运行一次的循环，可以使用反馈节点来代替循环结构和它的移位寄存器。反馈节点可以减少程序框图上的对象数量，让程序框图看上去更干净一点。图
4.31 就是使用反馈节点编写出的一个完全等效于上例的功能全局变量。

![](images/image273.png)

图 .31 等效的加减法功能全局变量

与前两种全局变量相比，功能全局变量有两个主要的优点。

首先，功能全局变量可以防止竞争状态出现。因为功能全局变量的 VI 是不可重入的，所以把它作为子 VI 时，绝对不可能出现两个功能全局变量 VI 同时执行的情况。因为全局变量的所有操作都是在这个 VI 内部完成的，也就意味着，所有对数据的操作都绝对不会被其它操作所干扰。

图
4.32 中的 VI，执行结束必然导致全局数据增加 1。即便此时还有其它线程的子 VI 在同时运行，其程序运行结果也必然是一个确定值。但是，需要注意的是，解决了竞争状态不等于全局变量的使用顺序可以乱写，错误的顺序仍然可能导致错误的运行结果。比如，在本例中，加减法的顺序是可以随意放置的，它们不影响程序最终的结果，但清零操作的顺序不能混乱。先做加法，还是先清零肯定会导致不同的程序运行结果。

设计功能全局变量时还可以加入出错处理的连线，以在使用时便于确定全局变量的调用顺序。

![](images/image274.png)

图 .32 使用功能全局变量

功能全局变量的另一优点是，功能全局变量中的全局数据只能被全局变量本身所使用。调用这个全局变量的程序只能使用全局变量提供的方法对数据进行操作。这样，就可以通过提供某些特定的数据操作方法，对访问模块中的数据加以限制，提高数据的安全性。

模块的编写者和使用这个模块编写应用程序的很可能不是同一个人。因此，模块开发者对模块的使用进行必要的限制，防止模块使用者对模块数据的滥用，是非常必要的。

上文所使用的例子中，故意没有提供 "写入数据" 的方法。因此功能全局变量的使用者在编写程序时是无法实现直接修改全局变量的值的，只能对这个数据清零或加减。比如，用户无法直接把全局变量中的数据设置为 3，它只能先调用 "清零" 方法，再调用 "加法" 把数值加到 3。

甚至，在某些情况下也可以不提供 "取出数据" 操作，让这个全局数据与模块使用者完全屏蔽。模块使用者只能利用全局变量提供的方法查看数据处理后的结果。这样全局数据被很好地隔离开来，避免了被不当改动的风险。

另外，如果全局数据的数据量比较大（如一个长数组），那么可以利用功能全局变量的这一特点，每次只把所需的全局数据中的某一部分写入或读出全局变量。这样就避免了大块数据的拷贝，提高了程序效率。

鉴于上述两个忧点，在需要使用全局变量的时候应当首先考虑使用功能全局变量。

功能全局变量相对于普通全局变量最主要的缺点就是需要额外的编写一段代码，创建起来稍费事些。

## 基于功能全局变量的程序功能模块

在 LabVIEW
8.0 之前的版本中，由于没有其它更好的对数据进行封装以及设置访问权限的方法，功能全局变量还常常被用来实现数据与方法的封装，以及限制数据访问权限等。功能全局变量的应用远远超出了全局变量这一范畴，它和状态机一起成了软件工程在 LabVIEW 中应用的两大法宝，一度受到很多 LabVIEW 程序员的极力推崇，以至于相当一部分 LabVIEW 程序模块都采用了功能全局变量模式。

目前，LabVIEW 中仍有很多功能模块是采用这种模式编写的。如果你的 LabVIEW 是 8.6 或之前的版本，可以打开 "\[LabVIEW\]\\vi.lib\\Utility\\config.llb\\Config
Data
Registry.vi"看一下。这个 VI 是" 配置文件 VI"的一个底层模块。函数选板" 编程 -\> 文件 I/O-\> 配置文件 VI" 中都是为 INI 文件（配置文件）提供接口的 VI。但是，打开这些 VI 的程序框图，就会发现，它们只是做了一些接口的包装工作。这些 VI 最终都调用 Config
Data Registry.vi 完成相应的功能。而 Config Data
Registry.vi 则采用功能全局变量模式，提供了对 INI 文件添加删除键值等的操作（图
4.33）。

![](images/image275.png)

图 .33 使用功能全局变量模式编写的程序功能模块

功能全局变量虽然有很多优点，但如果要把它作为更大的功能模块来使用，也同样存在很多不足。由于它和状态机都是基于循环条件结构的，因此，前文提到的状态机的缺点，功能全局变量也同样存在。

在使用功能全局变量模式编写的功能模块中，几乎所有的功能和数据接口都是在这个功能全局变量 VI 中完成的。如果模块的功能较为复杂，这个 VI 的连线也就十分复杂。比如图
4.33 中这个功能全局变量就非常复杂了，想弄清楚它的工作原理恐怕还得仔细阅读和研究一段时间。

模块功能复杂，往往接口的数据也多。把众多的接口数据放在一个 VI 上提供给用户，用户很可能被这个 VI 上的数据搞得晕头转向，不知该如何使用。正因如此，LabVIEW 并没有直接把 Config
Data
Registry.vi 暴露给用户去直接使用，而是对它的结构再封装一层，每个 VI 只负责读或写某一两个给用户使用的接口数据。这样就大大方便了用户的使用。

把所有的结构数据都放置在一个 VI 上也会给维护带来问题。比如，模块需要增加或改动某个功能，可能又得给它添加新的参数，甚至不得不改变 VI 连线板的模式。

现在只要使用 LabVIEW
8.2 以上的版本开发新的功能模块，就完全没有必要继续使用功能全局变量这种模式了。LabVIEW 从 8.2 版本起，开始支持面向对象的编程。面向对象的概念既包含了功能全局变量的优点，又克服了其缺点。我们会在后续的章节详细介绍面向对象的编程方法。